# ООП в Python "на пальцах" [01:10]
* Неполный взгляд: объект - это переменная, которая не только
  содержит данные, но и возит с собой код для управления ими.
## Базовый синтаксис [00:15]
Пишем свой `defaultdict`.

* self - ещё один параметр
* Конструктор `__init__`
* Всё, что в теле - статика (включая переменные!)
* Есть @staticmethod
* bounded vs unbounded method и его использование в map
* `isinstance` и `type()`

## Реализация в Python [00:10]
* `__dict__` - динамический словарь, `hasattr`
* Сравнение с C++: нет понятия "расположение в памяти" или "виртуальный вызов"
* Кто угодно создаёт любые свойства
* Что угодно - объект со свойствами (`dir`), даже функция, метод (`__call__`) и числа (`.bit_length()`, `.as_integer_ratio()`)

## Примеры: коллекции, итераторы  [00:15]
* Методы `__iter__` и `__next__` (шаблон "итератор")
  * "Магические методы" (просто стандартное название)
  * `StopIteration`
* Написание бесконечного списка
* Функции `iter` и `next`
* Использование в `for`
* Написание конечного списка
* Метод `__getitem__`
  * `KeyError`
  * `slice`
  * Ссылка на https://docs.python.org/3/reference/datamodel.html
## Генераторы [00:10]
* Ручная итерация по списку, `map`, `filter`
* Generator expression vs list comprehension
  * Сокращённый синтаксис при вызове процедур
* Синтаксический сахар: `yield`
## Перегрузка операторов [00:15]
* `==`, `*`, `+`
* Причины не перегружать:
  * Разное поведение у похожих типов (целочисленное деление в Python 2)
  * `||` похоже на "прямые параллельны", а `vec1 * vec2` может означать разное произведение
  * Скрывает сложные места (к процедурам все привыкли)
* `__add__` и `__radd__`, `NotImplemented`
* `__lt__` против `__gt__`, `total_ordering`
## Хэширование [00:05]
* `__hash__` и `__eq__`, аналог в Java
* Мутабельные объекты и хэширование в словари (`tuple` vs `list`)
* Полиномиальный хэш от строки и длинная арифметика

# Иеология [00:20]
## Контракты, инварианты, инкапсуляция [00:05]
* У объекта есть контракт: что с ним можно делать и как он себя ведёт
  * Этот контракт синтаксически сосредоточен в одном месте, легче проверять
* Инвариант - условия на внутреннее состояние объекта; как он себя ведёт и почему
  * Можно проверять assert'ами, нарушение - ошибка программиста, а не пользователя
* Интерфейсы для частичного описания контрактов
  * В Python - просто соглашения в документации
  * В C++/Java - реальные интерфейсы/абстрактные базовые классы
* Инкапсуляция: зафиксировали контракт, внутренности трогаем только мы,
  пряем детали реализации
  * Есть и в модульном программировании, и в процедурном (в меньшей степени)
    * Например, для файла: ID'шник от ОС, позиция, внутренний буфер...
  * В сумме это упрощает код и доказательства корректности
  * В C++/Java есть private/protected
  * В Python - просто соглашения в документации, что можно вызывать. А остальное - нельзя
  * Если что-то нельзя сделать через публичный интерфейс - не надо через приватный, иначе
    появляется дополнительная связь, да ещё и неявная. Лучше явно
* Бывают и POD/POJO (plain old data, plain old java object) - просто набор полей, ничего не делает.
  Что-то вроде `namedtuple` на стероидах, можно ещё свои методы добавлять
## Практика применения: структуры данных [00:05]
* Для коллекций/контейнеров/структур данных
* Пример: двоичная куча 
  * Абстрагировались от конкретного решения, чтобы выделить интерфейс, нужный для задачи
  * Хорошие методы: `push()`, `pop()`, `peek()`, `__init__()`
  * Не очень метод: `__getitem__(self, index)`, потому что массив с индексацией - это деталь реализации.
    Лучше уж `peek_second()` для получения второго максимума, скажем.
  * Опционально можно в конструкторе взять компаратор или ключ (`key`, как для `sorted`)
## Практика проектирования: параметрический полиморфизм [00:10]
* Параметрический полиморфизм (абстракция данных и методов)
  * Код одинаковый, но ведёт себя по-разному
  * Утиная типизация: важны только имена методов, динамически
    ищем нужный
  * Сравнение с C++: наследование и виртуальные функции для полиморфизма
* Для ситуаций, когда нужно немного разное поведение, но обработка обычно общая
Примеры:
* Обойти все элементы: цикл for, "итератор"
* Пишем игру в крестики нолики, хотим несколько ботов: "стратегия"
  * https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D1%80%D0%B0%D1%82%D0%B5%D0%B3%D0%B8%D1%8F_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)
* Хотим сделать отмену хода в крестиках-ноликах: "команда"
  * https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%B0%D0%BD%D0%B4%D0%B0_(%D1%88%D0%B0%D0%B1%D0%BB%D0%BE%D0%BD_%D0%BF%D1%80%D0%BE%D0%B5%D0%BA%D1%82%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F)

# Наследование и композиция [00:25]
## Наследование в Python [00:05]
* Получили не перезаписанные методы от родителя
* В новых методах (особенно `__init__`) стоит вызывать `super()`
* `isinstance` возвращает `True`, но `type()` другой: один стал подтипом
## Liskov Substitution Principle [00:10]
* Формулировка
* Пример, когда более-менее окей:
  * Событие у биржевой компании
    * Внутренний перевод (влияет на деньги или акции на счетах)
      * Между реальными юридическими счетами
      * Между виртуальными счетами
    * Внешнее событие
      * Появление компании с акциями
      * Разделение акций компании
      * Разделение компании
    * Сделка (меняем деньги на что-то, есть банк-посредник, есть брокер)
      * Покупка/продажа акций
      * Покупка/продажа опционов
      * Реализация опциона
    * Выплата дивидендов
  * Тогда можно смотреть и на все события, и пачками (например, "количество сделок" или "количество денег на счетах")
## Работа с разными типами [00:10]
* Соблюдать LSP сложно!
  * Квадрат/прямоугольник (правильного ответа нет)
  * "Изменяемый список", "список только для чтения", "неизменяемый список"
  * В Python: даже при утиной типизации (что именно мы ожидаем от списка?)
* Проблемы при наследовании данных ("точка" и "точка с номером"):
  * Как сравнивать разные виды точек?
    * Если никак, то нарушаем LSP
    * Если по общим полям, нарушаем транзитивность
    * Если сначала по типам, нарушаем здравый смысыл
* Проблема не в наследовании, а в подтипах!
  * Но наследование можно использовать только для переиспользования реализации

# Python ABC (Abstract base Class) [00:10]
* https://www.python.org/dev/peps/pep-3119/
* Эмуляция интерфейсов из Java/C++
* Помогает PyCharm понимать код
* Возникает ошибка _при создании объекта_ , если что-то не реализовать
  (Python - язык динамический)
* Позволяет формализовать утиную типизацию в отсутствие перегрузки функций:
  * Что если функция может принимать и объект, и коллекцию? Как отличить?
* https://docs.python.org/3/library/collections.abc.html
  * `Callable`
  * `Iterable`
  * `Iterator` (плюс примеси: автоматически получили `__iter__`)
  * `Sized`, `Container`, `Collection`

# Пояснения к домашнему заданию [00:15]
* Абстрактные синтаксические деревья для выражений
* Абстрактные синтаксические деревья для кода
* Язык "ЯТЬ"
  * `Scope` и динамическая область видимости
  * Как писать программы без переменных, рекурсия

# Тестирование: принципы FIRST [00:15]
https://stackoverflow.com/questions/18024785/tdd-first-principle

* Fast: тесты работают быстро
* Independent: можно запустить любое подмножество тестов
* Repeatable: тест не зависит от внешнего окружения и всегда даёт один и тот же результат
* Self-checking: не надо руками проверять (не)корректность
* Timely: пишется перед кодом или сразу после

Сильные требования в начале: I, R, S, они влияют на разбиение на процедуры/объекты.

# Тестирование: mock [00:15]
* `sys.stdin`, `monkeypatch` и `StringIO`
* Можно мокать даже `requests.get`, но осторожно: не появится ли дублирование кода в тесте?
* Пусть хотим протестировать объект, который зависит от других
  * Тогда он зависит от интерфейсов/контрактов, а не конкретных реализаций
  * Можно ему скормить "заглушку", которая ожидает определённые вызовы и отвечает, как надо
    * Заодно проверим, что заглушку вызывает, как надо
