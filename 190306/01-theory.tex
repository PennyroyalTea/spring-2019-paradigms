\begin{frame}[t]{Определения}
Определения работают и для ООП, и для модулей, и для функций.

\begin{itemize}
\item
	\textit{Контракт}/\textit{интерфейс} "--- соглашение о том, как
	и когда можно вызывать методы объекта (или процедуры), что возвращают.
\item
	\textit{Инвариант} "--- соглашении о внутреннем состоянии объекта
	(или цикла), внешний мир о нём не знает.
\item
	\textit{Интерфейс} "--- технический способ описать кусок контракта
	отдельно от реализации: какие функции с какими именами требуются.
	Есть в Java.
	В C++ являются частным случаем \textit{абстрактных базовых классов}.
\item
	\textit{Инкапсуляция} "--- идея о том, что детали реализации объекта
	(функции, модуля) внешний мир видеть не должнен и не должен от них
	зависеть.
	Хорошо сочетается с интерфейсами и статической типизацией:
	просто нельзя вызвать метод, не описанный в интерфейсе, даже если он есть.
\end{itemize}
\end{frame}

\begin{frame}[t,fragile]{POD/POJO}
\begin{itemize}
\item
	Обычно объект сочетает в себе данные, инвариант, контракт, методы для модификации состояния.
\item
	Можно идеологически выделить <<простые объекты>>, которые не реализуют формальные интерфейсы,
	ничем не управляют, с внешним миром не взаимодействуют.
\item
	Просто хранят данные, возможно, со вспомогательными методами;
	\verb`namedtuple` на стероидах
\item
	В C++ есть термин POD (более строгий и влияет на поведение): plain old data
\item
	В Java есть Plain Old Java Object
\end{itemize}
\end{frame}

\begin{frame}[t]{Параметрический полиморфизм}
\begin{itemize}
\item
	Можем написать код один раз, а он работает с объектами разных типов.
\item
	В Python "--- \textit{утиная типизация}: для работы с объектом требуется
	лишь наличие методов с нужными именами и их ожидаемое поведение.
\item
    \textbf{Если оно выглядит как утка, плавает как утка и крякает как утка, то это, вероятно, и есть утка.}
\item
	В Java/C++ требуется явно указать, что объект реализует некий \textit{интерфейс},
	тогда компилятор статически проверит и код, и тех, кто его вызывает.
\item
	Хотя в C++ есть шаблоны, там утиная типизация.
\item
	В Haskell "--- как в Java, только компилятор может сам догадаться о требованиях.
\end{itemize}
\end{frame}

\begin{frame}[t]{Наследование}
\begin{forest}
[{Событие у\\биржевой компании},for tree={align=center,draw,fit=tight,grow'=east}
	[{Внутренний\\перевод}
    	[...]]
  	[{Внешнее\\событие}
    	[{Разделение\\акций компании}]
    	[...]]
	[{Сделка}
    	[{Покупка, продажа акций}]
    	[...]]
  	[{Выплата\\дивидендов}]
	]
\end{forest}
\end{frame}
