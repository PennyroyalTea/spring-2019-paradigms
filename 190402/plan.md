# Ресурсы, многопоточность, план занятия [00:15]
* Память
  * Можно руками (C)
  * Можно RAII (C++)
  * Можно сборщиком мусора (Python)
* Типы ресурсов:
  * Память
  * Дескрипторы ОС (их конечное число): все примеры ниже, “кисть”, “контекст OpenGL для рисования”
  * Файлы (чтобы кэш сбросить)
  * Сетевые соединения (чтобы собеседник знал, что мы прекратили общение, а не игнорируем => можно у собеседника освободить ресурсы)
  * Memory-mapped file (нельзя размапить файл и уменьшить размер, пока есть ссылки на память, пример)
  * Мораль: сборщик мусора работает только с памятью. 
* Как управлять ресурсами?
  * Сборщик мусора: есть финализаторы, но они вызываются непонятно когда.
  * Менеджеры контекста в Python:
    * Про Java заикнуться, что можно try-with-resources: надо явно писать
    * RAII в C++
    * Нельзя перемещать владение (если только не C++)
  * Полностью ручное управление: надо много думать
* Сейчас расскажем общие для всех языков идеи ручного управления ресурсами. Писать будем на Rust, там встроен borrow checker, который во время компиляции строго доказывает, что с ресурсами всё ок.
  * Он может понять не всё, но многое. Как статическая типизация:
    * Покрывает кучу случаев, но можно придумать пример, когда borrow checker не пропустит корректный код. Потому что теорема Райса и halting problem.
       * Например, когда функция иногда не передаёт владение, а иногда возвращает его. Типа в переборе поле при неуспехе не изменилось, а при успехе переехало в возвращаемое значение
    * Тем не менее, приучает удобно думать

# Rust-1 [01:15]
## Базовый синтаксис
* Функции, макрос `println!` (`{}` и `{:?}`)
* `let`, `let mut`, `const`, автовывод типов, строгая статическая типизация
* Числа: типы данных, литералы, отсутствие конвертации
* Прочие типы: bool, tuple, массивы
  * Можно изменять тип и даже мутабельность при помощи `let`, это просто новая переменная создаётся
* Возврат значений из функции (`return` и выражение), тип возвращаемого значения
* Выражения `if`, `loop`/`break`
* Циклы `while` и `for` (`.iter()`, `.rev()`)
## Владение
* Базовые идеи (иногда их нарушают, но не мы). Полезны и в других языках.
  * У каждого объекта ровно один владелец, они так образуют дерево. Картинка
  * Владелец освобождает объект
  * Владение можно передавать (это действие по умолчанию; даже с параметрами и возвратом)
  * Владелец может кому-нибудь одолжить объект (например, себе)
* Из особенностей:
  * Двусвязных списков почти не бывает (кто владеет?), только односвязные
  * Глобальных переменных почти не бывает (когда инициализировать?)
* Примеры со строчками: move by default, но есть Clone (он бывает сложный)
* Пример Copy: int (когда достаточно копировать биты, для строк не подходит)
* Компилятор очень жёстко следит за владением (borrow checking), пример ошибки компиляции после move
   * Есть ещё unsafe-часть языка с указателями, мы туда не лезем
## Ссылки
* Строчки: корректные UTF-8 (не массивы), есть `push`, `push_str`
* Можно "одолжить" объект кому-нибудь (им)мутабельно, передав ссылку
  * Ссылки передаются явно: `&` или `&mut`
  * Это также включается в тип, надо разыменовывать (`*i += 1`) //, если только метод не вызываем
* Правила:
  * Либо одна пишущая ссылка, либо сколько угодно читающих
  * Все ссылки всегда корректны
* Компилятор за этим жёстко следит:
  * Можно делать shadow старых переменных на время scope
  * Можно сделать freeze мутабельной переменной, если одолжить её иммутабельно
  * На самом деле ему надо решать систему уравнений: какая переменная где кем владеется и как одалживается, и где удалять
* Картинка: дерево из владений отдельно, дерево ссылок отдельно
* Разница между `let x = 10` и `let x = &10`
## Слайсы
* Есть у строк (`&str`), есть у массивов (`&[i32]`)
* Кусок объекта, нельзя мутабельную ссылку на родителя и иммутабельную на кусок (или наоборот), аналогично с остальными правилами
  * Пример: взяли первое слово в строке, а потом строку очистили (compilation error)\
  * Картинка
* Как разрезать строку на независимые слайсы? Только unsafe и готовое API (`split_at`)
## Структуры
* Можно объявлять, по умолчанию владеют
  * Есть круглые скобки (типа tuple), есть фигурные (с именами)
  * Ссылки тоже можно держать, но тогда надо помогать компилятору решать систему уравнений (а то вдруг есть требование "все ссылки внутри живут одинаково")
  * Есть `Box<>` для рекурсии (`unique_ptr`/указатель)
* Можно `#[derive(Debug)]` и печатать
* Методы: раздел `impl`, поставили `self`/`&self`/`&mut self`
  * Разыменовывать при вызове не надо, стрелочек нет, всегда точка
## Option
* `Option` для результата `String.parse()`
* Enum'ы как объединения структур
* Автовывод типов при вызове `String.parse()` и turbofish
* Разбор на куски: `match`, `if let`, `_`
  * А что происходит со временем жизни при `match`? Картинка
## Обработка ошибок
* Исключений нет
* Есть `panic!` - необрабатываемая ошибка
* Все обрабатываемые - через `Option` и прочее
  * `std::io::stdin().read_line()` возвращает `Result`
* `unwrap`, `expect`
## Пример: "угадай число"
* `cargo new`, `cargo build`, `cargo run`, `cargo check`
* `cargo test`
* `extern crate` и `use`
* rand crate

# Rust-2 [00:30]
## Структуры данных
* `Vector` и `vec![]` против массивов
* Обобщённые функции (всё ещё статическая типизация!)
## Traits
* Отдельно от структур данных! И объявлены, и реализованы. Полиморфизм, однако.
* Пример: `fmt::Display`, `fmt::Debug`, для своей структуры вместо `#[derive(Debug)]`
* Более интересные: `Iterator` (`iter`, `iter_mut`, `into_iter`)
  * https://doc.rust-lang.org/std/iter/index.html
  * Какой тип у `map`? У `filter`?
* Можно использовать в обобщённых функциях (статический полиморфизм):
  * Параметр: `where T : Display`
  * Параметр: `(T: impl Display)`
## Замыкания
* Внутренние функции - не замыкания
* Синтаксис: `|x| x + 1`
* Типа нет, либо автовывод, либо `impl Fn(i32) -> i32`
  * В том числе в возвращаемом типе и это статическая типизация!
  * Есть и динамический полиморфизм, но мы не будем
* Куча проблем с временем жизни (Картинка):
  * Захватывают обычно по ссылке (если могут - по немутабельной)
  * Следствие: живут не дольше, чем переменные (нельзя захватить локальную функцию и вернуть; типа фабрика)
  * Но можно сказать `move ||` и всё себе захватит
* С их временем жизни тоже интересно (Картинка):
  * `Fn` вызывается сколько угодно раз по обычной ссылке, захватило только иммутабельные
  * `FnMut` вызывается только по иммутабельной ссылке, потому что внутри мутабельная
  * `FnOnce` вызывается один раз, потому что кому-то внутри себя передаёт владение захваченным объектом

# Многопоточность [00:15]
* Потоки работают параллельно: можно ускорять на процессорах, можно работать параллельно
* `spawn` (живёт до конца `main`), `join`
  * Надо `move ||`, никаких данных на запись не передать (потом разберём, почему)
  * Просто так передать объект в поток нельзя, надо ему trait'ов прописать
    (например, у замыканий по умолчанию нет), мы это делать не будем.
* Каналы: `mpsc` (multiple producer, single consumer), `spmc`
  * Передаёт владение, иначе неясно, кто удаляет строчку
  * Кстати, кто владеет каналом?
    * Тот, у кого один конец.
    * А что происходит с остальными после закрытия?
      * Возвращают ошибку. Вот и `Result`
* Конец канала надо клонировать

# Перебор пароля из цифр [00:15]
* Сначала пишем однопоточный
* Распилили перебор на две стадии (картинка): генерация задач и перебор
* Thread pool: отправили кучу задач, посчитали, подождали
  * Осторожно: не надо передавать внутрь ссылку на сам thread pool, иначе странная ошибка

# Перебор судоку [00:30]
* Пишем решение в один поток, подробно рассказываю
