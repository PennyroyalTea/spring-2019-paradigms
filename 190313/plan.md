# Идеология [00:15]
## Воспроизводимость [00:05]
* Код и требования часто меняются
* Код будет разрабатываться и запускаться на разных компьютерах
  * Даже если пишете проект только для себя: переустановка/смена ОС, потеряли компьютер, обновились...
* Требуется, чтобы код можно было разрабатывать и запускать где угодно
  * В идеале: скачали нечто, нажали одну кнопку, есть готовый проект в IDE для разработки
  * Обычно ограничиваются подробным README и использованием стандартных инструментов для сборки
  * Надо явно прописать что запускать, как собирать, какие нужные файлы в каких местах, какие библиотеки нужны...
* Можно автоматизировать проверку и тестирование на разных компьютерах!
* Иначе можно скачать код и обнаружить:
  * Нехватку файлов для компиляции
  * Запускается только в одной конкретной папке
  * Работает только если Python находится в конкретной папке
  * Работает только если открыть в PyCharm и настроить папочки определённым образом
* Чтобы достичь воспроизводимости, требуется вкладывать время и соблюдать процессы
  * Это может казаться "избыточным" на одном компьютере
  * Если внезапно потребуется, добавлять воспроизводимость больнее, чем делать с начала
* Пример: https://github.com/yeputons/csc-gpgpu-fall-2018-tasks

## Контроль версий [00:05]
* Код и требования часто меняются
* Иногда хочется:
  * Вернуть всё на последнюю рабочую версию
  * Посмотреть, что поменялось
  * Понять, откуда взялась странная строчка
  * Сделать много изменений, а потом перепроверить их по отдельности
  * Попробовать сделать сложное изменение
    * Возможно, несколькими способами
    * И чтобы можно было быстро между ними переключаться
* При работе в команде:
  * Все пункты выше особенно важны, потому что нет общего контекста
  * Несколько людей меняют один файл
  * Кто-то меняет несколько файлов согласованно (`.h` и `.cpp`), надо обновлять пачкой
  * Понять логику изменений за время отпуска
* При разработке ПО:
  * Точно знать, какой код сейчас запущен на сервере
  * Точно знать, какой код был запущен на сервере позавчера
  * Указывать версии нужных библиотек
  * Автоматически следить за номерами версий
* Иначе можно:
  * Не понять, где произошла ошибка: логи указывают на место, которого в текущем коде нет
  * Взять у коллеги только один обновлённый файл, остальные остаются старыми => не компилируется
  * Не понять, почему весь код поменялся за неделю и начать активно расспрашивать коллег
  * Не вспомнить, откуда взялась строчка, и бояться её убрать (вдруг важная)
* Чтобы контролировать версии, требуется вкладывать время и соблюдать процессы
  * Это тоже может казаться "избыточным", если вы работаете один
  * Но лучше вырабатывать привычку, в неожиданный момент пригождается
  * Если внезапно потребуется, добавить контроль версий невозможно. Только с конкретного момента времени.

## Система контроля версий [00:05]
* Система, которая позволяет вам все хотелки выше (в идеале) и:
  * Хранит все версии вашего кода
  * Позволяет между ними переключаться
  * Позволяет смотреть на изменений
  * Даёт удалённый доступ к коду (например, для команд)
  * "Общая папка" (email, dropbox, флешки, сетевой диск) сюда не попадает:
    надо руками создавать версии (`main4.cpp`), копировать всю папку, это муторно.
* Примеры: Git, Mercurial, SVN...
* Условная классификация:
  * Централизованные: один сервер, на котором хранится вся история (SVN), локально только текущая
  * Децентрализованные: на каждом отдельном компьютере хранится вся история, между собой как-то синхронизируются (например, через специальный условно-центральный компьютер)
* Система хранит несколько независимых _репозиториев_ (~ папка с историей)

# Базовое использование Git [01:10]
## Основное про Git [00:10]
* Git - одна из самых популярны DVCS (есть ещё Mercurial)
* Есть GitHub - это хостинг для репозиториев
* Храним один набор файлов целиком, версия - полное состояние файлов (и промежуточных папок)
  * Если файлы текстовые, то меняются несильно, можно "под капотом" оптимизировать
  * Если файлы бинарные, то копируются целиком => репозиторий большой
* История - направленный граф (КАРТИНКА)
  * Вершины - версии (коммиты), есть хэш (потому что распределённость)
    * Также "коммитом" называется: создание новой версии, изменения между версией и предыдущей
  * Рёбра ведут в предыдущие версии (обычно одно, но бывает и больше при merge/слиянии)
  * Вершины никогда не удаляются, данные только добавляются
* Есть "ветки" и "тэги": указатели на коммиты
  * Тэг по-хорошему не двигается (`0.7.4-alpha`)
  * Ветка двигается с разработкой (`master`, `issue-1365`)
  * https://learngitbranching.js.org/
* Все операции идут локально, синхронизация с сервером - отдельный процесс

## Общий процесс разработкиv [00:10]
### Зачем делить историю на коммиты? [00:05]
* Отделить изменение от остальных, например: рефакторинг/изменение имени функции от бага
  * Тогда можно отдельно проверять "механические" изменения и "содержательные"
    * Make Callback's SharedString a const ref.
      https://github.com/apache/incubator-pagespeed-mod/commit/338c37915355c0a4dd8726643cd90718bc394d6f#diff-f227b6faa8dc001f2312dadc7d72e53c
* Про каждое изменение рассказать, зачем оно было сделано
  * Чтобы потом можно было не спрашивать коллег (которые уволились), а читать историю
  * https://habr.com/ru/post/416887/
* Чтобы можно было откатываться между версиями
  * Никогда заранее не знаешь, куда захочешь откатиться, поэтому лучше делить на маленькие коммиты
  * Но не слишком маленькие, чтобы можно было осмысленно откатиться плюс-минус к любому коммиту
    * Деление "изменил имя функции в a.txt/b.txt" - плохое, потому что нельзя откатиться в середину

### Особенности реального мира [00:05]
* Сделали несколько изменений одновременно - несколько разных коммитов
  * А вдруг в каком-то баг? Тогда можно будет проще найти, в каком
  * Склеивать коммиты проще, чем разделять
* В репозиторий не идут:
  * Бинарники и промежуточные файлы
  * Настройки среды, особенно на конкретном компьютере (`.idea` иногда можно, но без `workspace.xml`)
  * Временные файлы: логи, папки для тестов, файлы для тестов
* Надо настроить так, чтобы СКВ об этом знала, иначе можно случайно добавить
* Чтобы проверить корректное состояние репозитория без учёта игнорированных файлов,
  можно автоматически запускать тесты на последней версии на "чистом" компьютере
* За репозиторием надо постоянно следить! "Поправить потом" очень больно и скорее невозможно
* Если что-то неудобно - спросите, наверняка можно настроить и добавить в привычку
  * Нельзя делать отладочный вывод, который не отключён по умолчанию
  * Нельзя читать из файлов по захадкоженному пути

## Базовые команды [00:20]
* `git config --user.name`, `git config --user.email`
* Три состояния: working directory, staging area, repository
* `git add`, `git commit`
* `git log`, `git blame`, `git show`, `git diff`, `git diff --color-moved`
* `git add -p`
* `.gitignore`
* `git branch`, `git tag`
* `git checkout` для веток
* `HEAD`, `git reset HEAD`
* `git checkout` для версий, `HEAD~1`
* `git reflog`
* `git stash`, `git stash list`

## Состояния файлов [00:10]
* Ignored, untracked, unmodified, modified, staged
* `git rm`

## Слияние веток [00:10]
* `git log --graph`
* `git merge`
* Merge conflict
* Fast-forward

## Remotes и GitHub [00:10]
* Что такое `origin/`
* `git remote add`, `git fetch`, `git push`
* `git clone`
* GitHub: регистрация, создание репозитория, просмотр истории
* GitHub: коммиты с сайта и конфликты

# Сторонние сервисы [00:50]
## Travis [00:10]
* Создание `.travis.yml`
* Подключение к Travis
* Добавление плашки в README
* Результат в списке коммитов

## Codecov [00:20]
* `pytest-cov`
* https://github.com/codecov/example-python

## GitHub: forks, pull requests и code review [00:20]
* Fork как быстрая копия репозитория
* Конвенция `origin`, `upstream`
* Pull request как запрос на merge/pull
* Процесс code review на GitHub

# Продвинутый git [00:20]
* cherry-pick вместо merge
* Смена  ветки при помощи `gi reset` (`--hard` и `--soft`)
  * Дальше можно новые коммиты
  * Переписывает историю!
  * Нельзя fast-forward и push!
* amend для добавления файлов/изменения сообщения
  * Комбинация `reset` и `cherry-pick` с изменением
* `rebase` как `reset`и несколько cherry-pick
  * Так можно "выпрямлять историю" при совместной работе над кодом
* `rebase -i`
  * Слияние коммитом (squash)
  * Разделение коммитов

# Как использовать [00:10]
* Вообще концепций много, тут только пример
* Одна ветка - стабильная, `master`
  * Всегда собирается
  * Всегда работает
* На каждую сложную фичу/рефакторинг своя ветка для экспериментов
  * Когда успех - либо `merge`, либо pull request
* Метод Микадо

# Ссылки
https://git-scm.com/book/ru/v2/
https://www.git-tower.com/learn/git/ebook
